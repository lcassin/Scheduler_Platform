sequenceDiagram
    participant Schedule as Quartz Schedule
    participant API as API Controller
    participant BgService as AdrBackgroundOrchestrationService
    participant Orchestrator as AdrOrchestratorService
    participant SyncService as AdrAccountSyncService
    participant AdrAPI as External ADR API
    participant DB as SQL Server
    participant Monitor as Monitor UI
    
    Note over Schedule,Monitor: ADR Full Cycle Orchestration (Background)
    
    Schedule->>API: POST /api/adr/orchestrate/run-background
    API->>BgService: QueueOrchestrationAsync(requestedBy)
    BgService->>DB: INSERT AdrOrchestrationRun (Status=Queued)
    BgService-->>API: RequestId (GUID)
    API-->>Schedule: 200 OK {requestId}
    
    Note over BgService,DB: Background Processing Begins
    
    BgService->>DB: UPDATE AdrOrchestrationRun SET Status=Running
    
    rect rgb(227, 242, 253)
        Note over BgService,DB: Step 1: Sync Accounts
        BgService->>Orchestrator: SyncAccountsAsync()
        Orchestrator->>SyncService: SyncAccountsAsync()
        SyncService->>DB: Query VendorCredNewUAT (billing patterns)
        DB-->>SyncService: Account data with billing analysis
        loop For each account
            SyncService->>DB: UPSERT AdrAccount (preserve overrides)
        end
        SyncService-->>Orchestrator: {inserted, updated, total}
        Orchestrator->>DB: UPDATE AdrOrchestrationRun (SyncAccountsInserted, etc)
    end
    
    rect rgb(255, 243, 224)
        Note over BgService,DB: Step 2: Create Jobs
        BgService->>Orchestrator: CreateJobsAsync()
        Orchestrator->>DB: SELECT AdrAccounts WHERE NextRunStatus IN ('Run Now', 'Due Soon')
        DB-->>Orchestrator: Due accounts (excluding Missing)
        loop For each account
            Orchestrator->>DB: Check existing job for period
            alt No existing job
                Orchestrator->>DB: INSERT AdrJob (Status=Pending)
            end
        end
        Orchestrator->>DB: UPDATE AdrOrchestrationRun (JobsCreated, JobsSkipped)
    end
    
    rect rgb(243, 229, 245)
        Note over BgService,AdrAPI: Step 3: Process Rebill
        BgService->>Orchestrator: ProcessRebillAsync()
        Orchestrator->>DB: SELECT AdrAccounts WHERE ExpectedBillingDayOfWeek = Today
        DB-->>Orchestrator: Accounts due for weekly rebill check
        par Parallel Processing (15 workers)
            loop For each account
                Orchestrator->>DB: Check for existing rebill this week
                alt Not already processed
                    Orchestrator->>AdrAPI: POST /Rebill {credentialId, accountId, isLastAttempt}
                    AdrAPI-->>Orchestrator: {statusId, statusDescription}
                    Orchestrator->>DB: Record rebill result
                end
            end
        end
        Orchestrator->>DB: UPDATE AdrOrchestrationRun (RebillSent, RebillFailed)
    end
    
    rect rgb(252, 228, 236)
        Note over BgService,AdrAPI: Step 4: Check Statuses (BEFORE sending new requests)
        BgService->>Orchestrator: CheckPendingStatusesAsync()
        Orchestrator->>DB: SELECT AdrJobs WHERE Status = ScrapeRequested
        DB-->>Orchestrator: Jobs with pending ADR requests
        par Parallel Processing (15 workers)
            loop For each job
                Orchestrator->>AdrAPI: GET /Status/{jobId}
                AdrAPI-->>Orchestrator: {statusId, statusDescription}
                alt Complete (StatusId 11)
                    Orchestrator->>DB: UPDATE AdrJob SET Status=Completed
                    Orchestrator->>DB: Advance AdrAccountRule to next billing cycle
                else No Documents Found (StatusId 13)
                    Orchestrator->>DB: Keep status - will retry today
                else Failed
                    Orchestrator->>DB: UPDATE AdrJob SET Status=Failed/NeedsReview
                end
            end
        end
        Orchestrator->>DB: UPDATE AdrOrchestrationRun (StatusesChecked, StatusesFailed)
    end
    
    rect rgb(232, 245, 233)
        Note over BgService,AdrAPI: Step 5: Send ADR Requests
        BgService->>Orchestrator: ProcessScrapingAsync()
        Orchestrator->>DB: SELECT AdrJobs WHERE Status=Pending AND NextRunDateTime <= Today
        DB-->>Orchestrator: Jobs ready for ADR requests
        par Parallel Processing (15 workers)
            loop For each job
                Orchestrator->>DB: Check for existing successful execution
                alt Not already requested AND within NextRangeEndDateTime
                    Orchestrator->>AdrAPI: POST /DownloadInvoice {credentialId, accountId, dateRange}
                    AdrAPI-->>Orchestrator: {indexId, statusId}
                    Orchestrator->>DB: INSERT AdrJobExecution
                    Orchestrator->>DB: UPDATE AdrJob SET Status=ScrapeRequested
                end
            end
        end
        Orchestrator->>DB: UPDATE AdrOrchestrationRun (ScrapingRequested, ScrapingFailed)
    end
    
    BgService->>DB: UPDATE AdrOrchestrationRun SET Status=Completed, CompletedDateTime
    
    Note over Monitor,DB: UI Monitoring (Polling)
    
    loop Every 2 seconds while running
        Monitor->>API: GET /api/adr/orchestrate/current
        API->>DB: SELECT TOP 1 AdrOrchestrationRun ORDER BY RequestedDateTime DESC
        DB-->>API: Current run with progress
        API-->>Monitor: {status, currentStep, processedItems, totalItems}
        Monitor->>Monitor: Update progress bars and step timeline
    end
