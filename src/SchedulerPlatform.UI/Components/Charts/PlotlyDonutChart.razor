@using Plotly.Blazor
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.ConfigLib
@using Plotly.Blazor.Traces
@using Plotly.Blazor.Interop
@using System.Text.Json
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div id="@_chartId">
    <PlotlyChart @ref="_chart" Data="_data" Layout="_layout" Config="_config" 
                 style="@($"width: 100%; height: {Height}; cursor: {(OnSliceClick.HasDelegate ? "pointer" : "default")};")" />
</div>

@code {
    [Parameter]
    public double[] Values { get; set; } = Array.Empty<double>();
    
    [Parameter]
    public string[] Labels { get; set; } = Array.Empty<string>();
    
    [Parameter]
    public string[] Colors { get; set; } = Array.Empty<string>();
    
    [Parameter]
    public string[] CustomData { get; set; } = Array.Empty<string>();
    
    [Parameter]
    public string Height { get; set; } = "300px";
    
    [Parameter]
    public bool ShowLegend { get; set; } = true;
    
    [Parameter]
    public string? Title { get; set; }
    
    [Parameter]
    public decimal HoleSize { get; set; } = 0.4m;
    
    [Parameter]
    public EventCallback<string> OnSliceClick { get; set; }

    private PlotlyChart? _chart;
    private IList<ITrace> _data = new List<ITrace>();
    private Plotly.Blazor.Layout _layout = new Plotly.Blazor.Layout();
    private Plotly.Blazor.Config _config = new Plotly.Blazor.Config();
    
    private string _chartId = $"plotly-donut-{Guid.NewGuid():N}";
    private DotNetObjectReference<PlotlyDonutChart>? _dotNetRef;
    private bool _isSubscribed = false;

    protected override void OnParametersSet()
    {
        BuildChart();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (OnSliceClick.HasDelegate && !_isSubscribed)
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            
            // Small delay to ensure Plotly has initialized the chart
            await Task.Delay(200);
            
            try
            {
                await JSRuntime.InvokeVoidAsync("chartInterop.subscribeToClick", _dotNetRef, _chartId);
                _isSubscribed = true;
            }
            catch
            {
                // Subscription failed - click events won't work but chart will still display
            }
        }
    }
    
    [JSInvokable]
    public async Task OnChartClickFromJs(JsonElement[] points)
    {
        if (!OnSliceClick.HasDelegate || points == null || points.Length == 0)
            return;
        
        var point = points[0];
        
        // Try to get PointNumber or PointIndex from the JSON
        int pointIndex = -1;
        if (point.TryGetProperty("PointNumber", out var pointNumber) && pointNumber.ValueKind == JsonValueKind.Number)
        {
            pointIndex = pointNumber.GetInt32();
        }
        else if (point.TryGetProperty("PointIndex", out var pointIdx) && pointIdx.ValueKind == JsonValueKind.Number)
        {
            pointIndex = pointIdx.GetInt32();
        }
        
        if (pointIndex < 0)
            return;
        
        // Get the clicked value from CustomData or Labels
        string clickedValue;
        if (CustomData.Any() && pointIndex < CustomData.Length)
        {
            clickedValue = CustomData[pointIndex];
        }
        else if (pointIndex < Labels.Length)
        {
            clickedValue = Labels[pointIndex];
        }
        else
        {
            return;
        }
        
        if (!string.IsNullOrEmpty(clickedValue))
        {
            await OnSliceClick.InvokeAsync(clickedValue);
        }
    }
    
    public async ValueTask DisposeAsync()
    {
        if (_isSubscribed)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("chartInterop.unsubscribeFromClick", _chartId);
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        _dotNetRef?.Dispose();
    }

    private void BuildChart()
    {
        var pieTrace = new Pie
        {
            Values = Values.Cast<object>().ToList(),
            Labels = Labels.Cast<object>().ToList(),
            CustomData = CustomData.Any() ? CustomData.Cast<object>().ToList() : null,
            TextInfo = Plotly.Blazor.Traces.PieLib.TextInfoFlag.Percent,
            HoverInfo = Plotly.Blazor.Traces.PieLib.HoverInfoFlag.Label | Plotly.Blazor.Traces.PieLib.HoverInfoFlag.Value | Plotly.Blazor.Traces.PieLib.HoverInfoFlag.Percent,
            Hole = HoleSize,
            Marker = new Plotly.Blazor.Traces.PieLib.Marker
            {
                Colors = Colors.Any() ? Colors.Cast<object>().ToList() : null
            }
        };

        _data = new List<ITrace> { pieTrace };

        _layout = new Plotly.Blazor.Layout
        {
            Title = !string.IsNullOrEmpty(Title) ? new Plotly.Blazor.LayoutLib.Title { Text = Title } : null,
            ShowLegend = ShowLegend,
            Legend = new List<Legend>
            {
                new Legend
                {
                    Orientation = Plotly.Blazor.LayoutLib.LegendLib.OrientationEnum.V,
                    X = 1.02m,
                    XAnchor = Plotly.Blazor.LayoutLib.LegendLib.XAnchorEnum.Left,
                    Y = 0.5m,
                    YAnchor = Plotly.Blazor.LayoutLib.LegendLib.YAnchorEnum.Middle
                }
            },
            Margin = new Plotly.Blazor.LayoutLib.Margin
            {
                L = ShowLegend ? 10 : 20,
                R = ShowLegend ? 120 : 20,
                T = 10,
                B = 10
            },
            PaperBgColor = "transparent",
            PlotBgColor = "transparent"
        };

        _config = new Plotly.Blazor.Config
        {
            Responsive = true,
            DisplayModeBar = DisplayModeBarEnum.False
        };
    }

    public async Task UpdateAsync()
    {
        if (_chart != null)
        {
            BuildChart();
            await _chart.React();
        }
    }
}
